#!/bin/bash
set -e

# ðŸŽ¨ Colors
GREEN="\e[32m"
YELLOW="\e[33m"
RED="\e[31m"
BLUE="\e[34m"
RESET="\e[0m"

# ðŸ“ Paths
CONFIG_FILE="$HOME/.create-repo.conf"
PLATFORM_FILE="$HOME/.create-repo.platforms"
REPO_LIST="$HOME/.repo-autosync.list"
LOG_FILE="$HOME/.create-repo.log"
ERROR_LOG="$HOME/.create-repo-errors.log"
SCRIPT_PATH="/usr/local/bin/update-all"
NOW=$(date "+%Y-%m-%d %H:%M:%S")

# ðŸŒŸ First run check
if [ ! -f "$CONFIG_FILE" ]; then
  echo -e "${BLUE}âœ¨ First time using create-repo â€” letâ€™s set things up!${RESET}"
  interactive=true
else
  source "$CONFIG_FILE"
  interactive=false
fi

# ðŸš© Flags
show_help=false
run_update=false
repo=""
forced_platform=""

# ðŸ” Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --help|-h) show_help=true ; shift ;;
    --update|--self-update) run_update=true ; shift ;;
    --platform=*) forced_platform="${1#*=}" ; shift ;;
    *) repo=$1 ; shift ;;
  esac
done

# ðŸ“˜ Help
if $show_help; then
  echo -e "${BLUE}ðŸ“¦ create-repo â€” CLI to create and sync Git repositories${RESET}"
  echo "Usage: create-repo [name] [options]"
  echo "Options: --update --help --platform=github|gitlab|bitbucket"
  exit 0
fi

# â¬†ï¸ Update logic
if $run_update; then
  echo -e "${BLUE}â¬†ï¸ Checking for updates...${RESET}"
  current_version=$(dpkg -s create-repo 2>/dev/null | grep '^Version:' | awk '{print $2}')
  latest_version=$(curl -s https://api.github.com/repos/justrunme/cra/releases/latest | grep '"tag_name":' | cut -d '"' -f 4 | sed 's/^v//')

  if [[ -z "$latest_version" ]]; then
    echo -e "${RED}âŒ Failed to get latest version${RESET}"
    exit 1
  fi

  echo -e "ðŸ”¢ Installed: ${YELLOW}${current_version:-not found}${RESET}"
  echo -e "ðŸŒ Latest: ${GREEN}$latest_version${RESET}"

  if [[ "$latest_version" == "$current_version" ]]; then
    echo -e "${BLUE}âœ… Already up-to-date${RESET}"
    exit 0
  fi

  echo -e "${BLUE}ðŸ“‚ Downloading .deb...${RESET}"
  latest_url=$(curl -s https://api.github.com/repos/justrunme/cra/releases/latest | grep browser_download_url | grep .deb | cut -d '"' -f 4)
  if [[ -n "$latest_url" ]]; then
    tmp_deb=$(mktemp)
    curl -L "$latest_url" -o "$tmp_deb"
    sudo dpkg -i "$tmp_deb" && echo -e "${GREEN}âœ… Updated to $latest_version!${RESET}"
    rm -f "$tmp_deb"
  else
    echo -e "${RED}âŒ Could not download .deb${RESET}"
  fi
  exit 0
fi

# ðŸ¤– Interactive setup
if $interactive; then
  echo ""
  echo -ne "${YELLOW}ðŸ“¦ Repo name [$(basename "$PWD")]: ${RESET}"
  read input_repo
  repo=${input_repo:-$(basename "$PWD")}

  echo -ne "${YELLOW}ðŸ” Type (public/private) [public]: ${RESET}"
  read visibility_input
  default_visibility=${visibility_input:-public}

  echo -ne "${YELLOW}ðŸ‘¥ GitHub team (optional) [none]: ${RESET}"
  read input_team
  default_team=${input_team:-}

  echo -ne "${YELLOW}â± Sync interval (minutes) [1]: ${RESET}"
  read interval_input
  default_cron_interval=${interval_input:-1}

  cat > "$CONFIG_FILE" <<EOF
default_visibility=$default_visibility
default_cron_interval=$default_cron_interval
default_team=$default_team
EOF

  echo -e "${GREEN}âœ… Saved to $CONFIG_FILE${RESET}"
fi

# ðŸ§­ Determine platform (check local override first)
saved_platform=$(grep "^$PWD=" "$PLATFORM_FILE" 2>/dev/null | cut -d= -f2)
if [[ -n "$forced_platform" ]]; then
  platform="$forced_platform"
  grep -v "^$PWD=" "$PLATFORM_FILE" 2>/dev/null > "$PLATFORM_FILE.tmp" && mv "$PLATFORM_FILE.tmp" "$PLATFORM_FILE"
  echo "$PWD=$platform" >> "$PLATFORM_FILE"
elif [[ -n "$saved_platform" ]]; then
  platform="$saved_platform"
else
  available=()
  command -v gh &>/dev/null && available+=("github")
  [ -n "$GITLAB_TOKEN" ] && available+=("gitlab")
  [ -n "$BITBUCKET_USERNAME" ] && [ -n "$BITBUCKET_APP_PASSWORD" ] && available+=("bitbucket")

  if [ ${#available[@]} -eq 0 ]; then
    echo -e "${RED}âŒ No version control platform found.${RESET}"
    exit 1
  elif [ ${#available[@]} -eq 1 ]; then
    platform="${available[0]}"
  else
    echo -e "${BLUE}âš ï¸ Multiple platforms detected: ${available[*]}${RESET}"
    echo -ne "${YELLOW}â“ Choose default platform for this folder: ${RESET}"
    select choice in "${available[@]}"; do
      platform="$choice"
      echo "$PWD=$platform" >> "$PLATFORM_FILE"
      break
    done
    echo -e "${BLUE}â„¹ï¸ Tip: use --platform=github|gitlab|bitbucket to override per folder${RESET}"
  fi
fi

# ðŸš€ Git init and pull
if [ -d .git ] && git remote get-url origin &>/dev/null; then
  if $interactive; then
    echo -ne "${YELLOW}ðŸ“¥ Pull latest before continue? [y/N]: ${RESET}"
    read pull_choice
    [[ "$pull_choice" =~ ^[Yy]$ ]] && git pull origin "$(git symbolic-ref --short HEAD)"
  fi
else
  git init
  git checkout -b main
fi

# ðŸ“„ Add basic files
[ ! -f README.md ] && echo "# $repo" > README.md
[ ! -f .gitignore ] && echo ".DS_Store" > .gitignore
git add .
git commit -m "Initial commit at $NOW" &>/dev/null || true

# ðŸš€ Create repo
if [[ "$platform" == "github" ]]; then
  user=$(gh api user --jq .login)
  remote_url="git@github.com:$user/$repo.git"
  if ! gh repo view "$repo" &>/dev/null; then
    args="--$default_visibility --source=."
    [[ -n "$default_team" ]] && args="$args --team $default_team"
    gh repo create "$repo" $args --push || {
      echo "$NOW | ERROR creating GitHub repo" >> "$ERROR_LOG"
      exit 1
    }
  fi
elif [[ "$platform" == "gitlab" ]]; then
  response=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
    --data "name=$repo&visibility=$default_visibility" https://gitlab.com/api/v4/projects)
  remote_url=$(echo "$response" | grep -oP '"ssh_url_to_repo":"\K[^"]+')
elif [[ "$platform" == "bitbucket" ]]; then
  curl -s -u "$BITBUCKET_USERNAME:$BITBUCKET_APP_PASSWORD" \
    -X POST "https://api.bitbucket.org/2.0/repositories/$BITBUCKET_USERNAME/$repo" \
    -H "Content-Type: application/json" \
    -d "{\"scm\": \"git\", \"is_private\": $( [[ "$default_visibility" == "private" ]] && echo true || echo false ) }"
  remote_url="git@bitbucket.org:$BITBUCKET_USERNAME/$repo.git"
fi

git remote get-url origin &>/dev/null || git remote add origin "$remote_url"
git push -u origin "$(git symbolic-ref --short HEAD)" &>/dev/null || true

# ðŸ“ Track
grep -qxF "$PWD" "$REPO_LIST" || echo "$PWD" >> "$REPO_LIST"
echo "$NOW | $PWD | synced to $platform as $repo" >> "$LOG_FILE"

# â± Cron / Launchd
if [[ "$OSTYPE" == "darwin"* ]]; then
  plist="$HOME/Library/LaunchAgents/com.create-repo.auto.plist"
  cat > "$plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.create-repo.auto</string>
  <key>ProgramArguments</key>
  <array>
    <string>$SCRIPT_PATH</string>
  </array>
  <key>StartInterval</key>
  <integer>$((default_cron_interval * 60))</integer>
  <key>RunAtLoad</key>
  <true/>
</dict>
</plist>
EOF
  launchctl unload "$plist" &>/dev/null || true
  launchctl load "$plist"
else
  TMP_CRON=$(mktemp)
  crontab -l 2>/dev/null | grep -v "$SCRIPT_PATH" > "$TMP_CRON"
  echo "*/$default_cron_interval * * * * $SCRIPT_PATH # auto-sync by create-repo" >> "$TMP_CRON"
  sort -u "$TMP_CRON" -o "$TMP_CRON"
  crontab "$TMP_CRON"
  rm "$TMP_CRON"
fi

# âœ… Done
echo ""
echo -e "${GREEN}ðŸŽ‰ Repo '$repo' synced to $platform${RESET}"
echo "ðŸ“ Path: $PWD"
echo "ðŸ“ Tracked in: $REPO_LIST"
echo "â± Sync every: $default_cron_interval min"
echo "â„¹ï¸ Change settings: nano ~/.create-repo.conf"

if command -v notify-send &>/dev/null; then
  notify-send "create-repo" "Repo '$repo' initialized and pushed to $platform"
fi
